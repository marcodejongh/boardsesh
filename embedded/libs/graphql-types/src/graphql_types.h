/**
 * Auto-generated GraphQL Types for ESP32 Firmware
 *
 * Generated: 2026-02-03T05:56:00.785Z
 * Source: packages/shared-schema/src/schema.ts
 *
 * DO NOT EDIT MANUALLY - This file is generated by:
 *   npm run controller:codegen
 *
 * These types are compatible with ArduinoJson for JSON serialization.
 */

#ifndef GRAPHQL_TYPES_H
#define GRAPHQL_TYPES_H

#include <Arduino.h>
#include <stdint.h>
#include <stddef.h>

// ============================================
// GraphQL Type Constants
// ============================================

namespace GraphQLTypename {
    constexpr const char* LED_UPDATE = "LedUpdate";
    constexpr const char* CONTROLLER_PING = "ControllerPing";
}

// ============================================
// GraphQL Types for Controller
// ============================================

/**
 * Output type: LedCommand
 * Generated from GraphQL schema
 */
struct LedCommand {
    int32_t position;
    uint8_t r;
    uint8_t g;
    uint8_t b;
};

/**
 * Input type: LedCommandInput
 * Generated from GraphQL schema
 */
struct LedCommandInput {
    int32_t position;
    uint8_t r;
    uint8_t g;
    uint8_t b;
    int32_t role;
};

/**
 * Output type: LedUpdate
 * Generated from GraphQL schema
 */
struct LedUpdate {
    LedCommand* commands;
    size_t commandsCount;
    const char* climbUuid;
    const char* climbName;
    int32_t angle;
};

/**
 * Output type: ControllerPing
 * Generated from GraphQL schema
 */
struct ControllerPing {
    const char* timestamp;
};

/**
 * Output type: ClimbMatchResult
 * Generated from GraphQL schema
 */
struct ClimbMatchResult {
    bool matched;
    const char* climbUuid;
    const char* climbName;
};

/**
 * Input type: DeviceLogEntry
 * Generated from GraphQL schema
 */
struct DeviceLogEntry {
    float ts;
    const char* level;
    const char* component;
    const char* message;
    const char* metadata;
};

/**
 * Output type: SendDeviceLogsResponse
 * Generated from GraphQL schema
 */
struct SendDeviceLogsResponse {
    bool success;
    int32_t accepted;
};

// // Union type: ControllerEvent = LedUpdate | ControllerPing
// Use __typename field to determine actual type


// ============================================
// GraphQL Operations for ESP32 Controller
// ============================================

namespace GraphQLOps {

/**
 * Subscription: Controller Events
 * Receives LED updates and ping events from the backend
 */
constexpr const char* CONTROLLER_EVENTS_SUBSCRIPTION =
    "subscription ControllerEvents($sessionId: ID!) { "
    "controllerEvents(sessionId: $sessionId) { "
    "... on LedUpdate { __typename commands { position r g b } climbUuid climbName angle } "
    "... on ControllerPing { __typename timestamp } "
    "} }";

/**
 * Mutation: Set Climb From LED Positions
 * Sends LED positions from Bluetooth to match a climb
 */
constexpr const char* SET_CLIMB_FROM_LED_POSITIONS =
    "mutation SetClimbFromLeds($sessionId: ID!, $positions: [LedCommandInput!]!) { "
    "setClimbFromLedPositions(sessionId: $sessionId, positions: $positions) { "
    "matched climbUuid climbName } }";

/**
 * Mutation: Controller Heartbeat
 * Keep-alive ping to update lastSeenAt
 */
constexpr const char* CONTROLLER_HEARTBEAT =
    "mutation ControllerHeartbeat($sessionId: ID!) { "
    "controllerHeartbeat(sessionId: $sessionId) }";

/**
 * Mutation: Send Device Logs
 * Forward device logs to backend for Axiom ingestion
 */
constexpr const char* SEND_DEVICE_LOGS =
    "mutation SendDeviceLogs($input: SendDeviceLogsInput!) { "
    "sendDeviceLogs(input: $input) { success accepted } }";

} // namespace GraphQLOps

// ============================================
// JSON Parsing Helpers (ArduinoJson)
// ============================================

#include <ArduinoJson.h>

/**
 * Parse a LedCommand from a JsonObject
 */
inline bool parseLedCommand(JsonObject& obj, LedCommand& cmd) {
    if (!obj.containsKey("position")) return false;
    cmd.position = obj["position"];
    cmd.r = obj["r"] | 0;
    cmd.g = obj["g"] | 0;
    cmd.b = obj["b"] | 0;
    return true;
}

/**
 * Parse a LedUpdate from a JsonObject
 * Note: Caller must free commands array when done
 */
inline bool parseLedUpdate(JsonObject& obj, LedUpdate& update) {
    JsonArray commands = obj["commands"];
    if (commands.isNull()) {
        update.commands = nullptr;
        update.commandsCount = 0;
    } else {
        update.commandsCount = commands.size();
        update.commands = new LedCommand[update.commandsCount];
        size_t i = 0;
        for (JsonObject cmd : commands) {
            parseLedCommand(cmd, update.commands[i++]);
        }
    }
    update.climbUuid = obj["climbUuid"] | nullptr;
    update.climbName = obj["climbName"] | nullptr;
    update.angle = obj["angle"] | 0;
    return true;
}

/**
 * Parse a ClimbMatchResult from a JsonObject
 */
inline bool parseClimbMatchResult(JsonObject& obj, ClimbMatchResult& result) {
    result.matched = obj["matched"] | false;
    result.climbUuid = obj["climbUuid"] | nullptr;
    result.climbName = obj["climbName"] | nullptr;
    return true;
}

/**
 * Serialize a LedCommandInput to a JsonObject
 */
inline void serializeLedCommandInput(JsonObject& obj, const LedCommandInput& cmd) {
    obj["position"] = cmd.position;
    obj["r"] = cmd.r;
    obj["g"] = cmd.g;
    obj["b"] = cmd.b;
    if (cmd.role >= 0) {
        obj["role"] = cmd.role;
    }
}

/**
 * Serialize a DeviceLogEntry to a JsonObject
 */
inline void serializeDeviceLogEntry(JsonObject& obj, const DeviceLogEntry& entry) {
    obj["ts"] = entry.ts;
    obj["level"] = entry.level;
    obj["component"] = entry.component;
    obj["message"] = entry.message;
    if (entry.metadata) {
        obj["metadata"] = entry.metadata;
    }
}

#endif // GRAPHQL_TYPES_H
