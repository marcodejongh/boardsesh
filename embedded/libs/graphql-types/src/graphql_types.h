/**
 * Auto-generated GraphQL Types for ESP32 Firmware
 *
 * Source: packages/shared-schema/src/schema.ts
 *
 * DO NOT EDIT MANUALLY - This file is generated by:
 *   npm run controller:codegen
 *
 * These types are compatible with ArduinoJson for JSON serialization.
 */

#ifndef GRAPHQL_TYPES_H
#define GRAPHQL_TYPES_H

#include <Arduino.h>
#include <stdint.h>
#include <stddef.h>

// ============================================
// GraphQL Type Constants
// ============================================

namespace GraphQLTypename {
    constexpr const char* LED_UPDATE = "LedUpdate";
    constexpr const char* CONTROLLER_PING = "ControllerPing";
}

// ============================================
// GraphQL Types for Controller
// ============================================

// Include guard: LedCommand may also be defined in led_controller.h for native tests
#ifndef LEDCOMMAND_DEFINED
#define LEDCOMMAND_DEFINED
/**
 * Output type: LedCommand
 * Generated from GraphQL schema
 */
struct LedCommand {
    int32_t position;
    uint8_t r;
    uint8_t g;
    uint8_t b;
};
#endif // LEDCOMMAND_DEFINED

/**
 * Input type: LedCommandInput
 * Generated from GraphQL schema
 */
struct LedCommandInput {
    int32_t position;
    uint8_t r;
    uint8_t g;
    uint8_t b;
    int32_t role;
};

/**
 * Output type: LedUpdate
 * Generated from GraphQL schema
 */
struct LedUpdate {
    LedCommand* commands;
    size_t commandsCount;
    const char* climbUuid;
    const char* climbName;
    int32_t angle;
};

/**
 * Output type: ControllerPing
 * Generated from GraphQL schema
 */
struct ControllerPing {
    const char* timestamp;
};

/**
 * Output type: ClimbMatchResult
 * Generated from GraphQL schema
 */
struct ClimbMatchResult {
    bool matched;
    const char* climbUuid;
    const char* climbName;
};

/**
 * Input type: DeviceLogEntry
 * Generated from GraphQL schema
 */
struct DeviceLogEntry {
    float ts;
    const char* level;
    const char* component;
    const char* message;
    const char* metadata;
};

/**
 * Output type: SendDeviceLogsResponse
 * Generated from GraphQL schema
 */
struct SendDeviceLogsResponse {
    bool success;
    int32_t accepted;
};

// // Union type: ControllerEvent = LedUpdate | ControllerPing
// Use __typename field to determine actual type


// ============================================
// GraphQL Operations for ESP32 Controller
// ============================================

namespace GraphQLOps {

/**
 * Subscription: Controller Events
 * Receives LED updates and ping events from the backend
 */
constexpr const char* CONTROLLER_EVENTS_SUBSCRIPTION =
    "subscription ControllerEvents($sessionId: ID!) { "
    "controllerEvents(sessionId: $sessionId) { "
    "... on LedUpdate { __typename commands { position r g b } climbUuid climbName angle } "
    "... on ControllerPing { __typename timestamp } "
    "} }";

/**
 * Mutation: Set Climb From LED Positions
 * Sends LED positions from Bluetooth to match a climb
 */
constexpr const char* SET_CLIMB_FROM_LED_POSITIONS =
    "mutation SetClimbFromLeds($sessionId: ID!, $positions: [LedCommandInput!]!) { "
    "setClimbFromLedPositions(sessionId: $sessionId, positions: $positions) { "
    "matched climbUuid climbName } }";

/**
 * Mutation: Controller Heartbeat
 * Keep-alive ping to update lastSeenAt
 */
constexpr const char* CONTROLLER_HEARTBEAT =
    "mutation ControllerHeartbeat($sessionId: ID!) { "
    "controllerHeartbeat(sessionId: $sessionId) }";

/**
 * Mutation: Send Device Logs
 * Forward device logs to backend for Axiom ingestion
 */
constexpr const char* SEND_DEVICE_LOGS =
    "mutation SendDeviceLogs($input: SendDeviceLogsInput!) { "
    "sendDeviceLogs(input: $input) { success accepted } }";

} // namespace GraphQLOps

// ============================================
// Constants
// ============================================

/** Sentinel value indicating role field is not set */
constexpr int32_t ROLE_NOT_SET = -1;

// ============================================
// JSON Parsing Helpers (ArduinoJson)
// ============================================
//
// IMPORTANT: String pointer lifetime
// ----------------------------------
// The climbUuid, climbName, and other const char* fields returned by parse
// functions point directly into the JsonDocument's memory. These pointers
// become invalid when the JsonDocument is destroyed or modified.
//
// If you need to keep string values beyond the JsonDocument's lifetime,
// copy them to your own buffers before the document goes out of scope.

#include <ArduinoJson.h>
#include <new>  // for std::nothrow

/**
 * Parse a LedCommand from a JsonObject
 */
inline bool parseLedCommand(JsonObject& obj, LedCommand& cmd) {
    if (!obj.containsKey("position")) return false;
    cmd.position = obj["position"];
    cmd.r = obj["r"] | 0;
    cmd.g = obj["g"] | 0;
    cmd.b = obj["b"] | 0;
    return true;
}

/**
 * Parse a LedUpdate from a JsonObject
 *
 * IMPORTANT: This allocates memory for the commands array.
 * You MUST call freeLedUpdate() when done to avoid memory leaks.
 *
 * String pointers (climbUuid, climbName) point into the JsonDocument
 * and become invalid when the document is destroyed.
 *
 * NOTE: angle defaults to 0 if not present. Since 0 is a valid angle,
 * callers cannot distinguish "no angle" from "angle=0". If this matters,
 * check obj.containsKey("angle") before calling.
 *
 * @return false if memory allocation fails, true otherwise
 */
inline bool parseLedUpdate(JsonObject& obj, LedUpdate& update) {
    JsonArray commands = obj["commands"];
    if (commands.isNull()) {
        update.commands = nullptr;
        update.commandsCount = 0;
    } else {
        update.commandsCount = commands.size();
        update.commands = new (std::nothrow) LedCommand[update.commandsCount];
        if (update.commands == nullptr) {
            update.commandsCount = 0;
            return false;  // Allocation failed
        }
        size_t i = 0;
        for (JsonObject cmd : commands) {
            parseLedCommand(cmd, update.commands[i++]);
        }
    }
    update.climbUuid = obj["climbUuid"] | nullptr;
    update.climbName = obj["climbName"] | nullptr;
    update.angle = obj["angle"] | 0;
    return true;
}

/**
 * Free memory allocated by parseLedUpdate()
 * Safe to call even if commands is nullptr
 */
inline void freeLedUpdate(LedUpdate& update) {
    if (update.commands != nullptr) {
        delete[] update.commands;
        update.commands = nullptr;
        update.commandsCount = 0;
    }
}

/**
 * Parse a ClimbMatchResult from a JsonObject
 *
 * String pointers (climbUuid, climbName) point into the JsonDocument
 * and become invalid when the document is destroyed.
 */
inline bool parseClimbMatchResult(JsonObject& obj, ClimbMatchResult& result) {
    result.matched = obj["matched"] | false;
    result.climbUuid = obj["climbUuid"] | nullptr;
    result.climbName = obj["climbName"] | nullptr;
    return true;
}

/**
 * Serialize a LedCommandInput to a JsonObject
 * Set cmd.role to ROLE_NOT_SET (-1) to omit the role field
 */
inline void serializeLedCommandInput(JsonObject& obj, const LedCommandInput& cmd) {
    obj["position"] = cmd.position;
    obj["r"] = cmd.r;
    obj["g"] = cmd.g;
    obj["b"] = cmd.b;
    if (cmd.role != ROLE_NOT_SET) {
        obj["role"] = cmd.role;
    }
}

/**
 * Serialize a DeviceLogEntry to a JsonObject
 */
inline void serializeDeviceLogEntry(JsonObject& obj, const DeviceLogEntry& entry) {
    obj["ts"] = entry.ts;
    obj["level"] = entry.level;
    obj["component"] = entry.component;
    obj["message"] = entry.message;
    if (entry.metadata) {
        obj["metadata"] = entry.metadata;
    }
}

#endif // GRAPHQL_TYPES_H
