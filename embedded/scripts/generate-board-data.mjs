#!/usr/bin/env node
/**
 * Board Data Code Generator for ESP32 Firmware
 *
 * Reads board configuration data (product sizes, hold placements, LED mappings,
 * board images) from the web app's generated data files and produces C++ header
 * files with PROGMEM JPEG image arrays and hold coordinate mappings.
 *
 * These headers are compiled into the Waveshare 7" display firmware so it can
 * render board images with colored hold circle overlays at runtime.
 *
 * Usage:
 *   node embedded/scripts/generate-board-data.mjs
 *
 * Or via npm script:
 *   npm run controller:codegen:board-data
 */

import * as fs from 'fs';
import * as path from 'path';
import { fileURLToPath } from 'url';

// ESM-compatible __dirname
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// Path configuration
const PROJECT_ROOT = path.join(__dirname, '../..');
const WEB_LIB = path.join(PROJECT_ROOT, 'packages/web/app/lib');
const GENERATED_DIR = path.join(WEB_LIB, '__generated__');
const IMAGES_BASE = path.join(PROJECT_ROOT, 'packages/web/public/images');
const OUTPUT_DIR = path.join(__dirname, '../libs/board-data/src');

// Target image dimensions for the 480x800 display
const MAX_IMAGE_WIDTH = 400;
const MAX_IMAGE_HEIGHT = 560;
const JPEG_QUALITY = 70;

// Only generate for these boards (skip moonboard)
const BOARD_NAMES = ['kilter', 'tension'];

/**
 * Extract a JavaScript object/array literal from TypeScript source by
 * finding the variable declaration and balanced-brace parsing the value.
 *
 * Uses indirect eval() on the extracted literal only (not arbitrary code).
 * Input is always from trusted local source files generated by our own
 * build tooling, so this is acceptable. A full TS parser (e.g., ts-morph)
 * would be more robust but adds a heavy dependency for a build-time script.
 */
function extractJsObject(content, varName) {
  // Find the variable declaration and extract the object literal
  const regex = new RegExp(`(?:export\\s+)?const\\s+${varName}\\s*(?::[^=]+=|=)\\s*`);
  const match = regex.exec(content);
  if (!match) return null;

  const startIdx = match.index + match[0].length;
  let depth = 0;
  let inString = false;
  let stringChar = '';
  let i = startIdx;

  for (; i < content.length; i++) {
    const ch = content[i];
    if (inString) {
      if (ch === '\\') { i++; continue; }
      if (ch === stringChar) inString = false;
      continue;
    }
    if (ch === "'" || ch === '"' || ch === '`') {
      inString = true;
      stringChar = ch;
      continue;
    }
    if (ch === '{' || ch === '[') depth++;
    if (ch === '}' || ch === ']') {
      depth--;
      if (depth === 0) { i++; break; }
    }
  }

  const objStr = content.substring(startIdx, i);
  // Remove trailing semicolons and 'as const'
  const cleaned = objStr.replace(/\s*as\s+const\s*;?\s*$/, '').replace(/;\s*$/, '');
  try {
    // Indirect eval to parse the extracted object literal.
    // SAFETY: input is from local generated TS data files, not user input.
    return (0, eval)('(' + cleaned + ')');
  } catch (e) {
    console.error(`Failed to parse ${varName}:`, e.message);
    return null;
  }
}

/**
 * Load all required data from the TypeScript source files
 */
function loadBoardData() {
  console.log('Loading board data from TypeScript source files...');

  // Read raw file contents
  const productSizesContent = fs.readFileSync(
    path.join(GENERATED_DIR, 'product-sizes-data.ts'), 'utf-8'
  );
  const ledPlacementsContent = fs.readFileSync(
    path.join(GENERATED_DIR, 'led-placements-data.ts'), 'utf-8'
  );
  const boardDataContent = fs.readFileSync(
    path.join(WEB_LIB, 'board-data.ts'), 'utf-8'
  );

  // Extract data objects
  const PRODUCT_SIZES = extractJsObject(productSizesContent, 'PRODUCT_SIZES');
  const LAYOUTS = extractJsObject(productSizesContent, 'LAYOUTS');
  const SETS = extractJsObject(productSizesContent, 'SETS');
  const IMAGE_FILENAMES = extractJsObject(productSizesContent, 'IMAGE_FILENAMES');
  const HOLE_PLACEMENTS = extractJsObject(productSizesContent, 'HOLE_PLACEMENTS');
  const LED_PLACEMENTS = extractJsObject(ledPlacementsContent, 'LED_PLACEMENTS');
  const BOARD_IMAGE_DIMENSIONS = extractJsObject(boardDataContent, 'BOARD_IMAGE_DIMENSIONS');

  if (!PRODUCT_SIZES || !SETS || !IMAGE_FILENAMES || !HOLE_PLACEMENTS || !LED_PLACEMENTS || !BOARD_IMAGE_DIMENSIONS) {
    throw new Error('Failed to load one or more required data objects');
  }

  console.log(`  PRODUCT_SIZES: ${Object.keys(PRODUCT_SIZES.kilter || {}).length} kilter, ${Object.keys(PRODUCT_SIZES.tension || {}).length} tension`);
  console.log(`  SETS: ${Object.keys(SETS.kilter || {}).length} kilter, ${Object.keys(SETS.tension || {}).length} tension`);
  console.log(`  IMAGE_FILENAMES: ${Object.keys(IMAGE_FILENAMES.kilter || {}).length} kilter, ${Object.keys(IMAGE_FILENAMES.tension || {}).length} tension`);
  console.log(`  LED_PLACEMENTS: ${Object.keys(LED_PLACEMENTS.kilter || {}).length} kilter, ${Object.keys(LED_PLACEMENTS.tension || {}).length} tension`);

  return { PRODUCT_SIZES, LAYOUTS, SETS, IMAGE_FILENAMES, HOLE_PLACEMENTS, LED_PLACEMENTS, BOARD_IMAGE_DIMENSIONS };
}

/**
 * Enumerate all board configurations (board_name/layout_id/size_id/set_ids)
 * Returns array of config objects with all the data needed for code generation
 */
function enumerateConfigs(data) {
  const configs = [];

  for (const boardName of BOARD_NAMES) {
    const sets = data.SETS[boardName] || {};

    for (const [layoutSizeKey, setList] of Object.entries(sets)) {
      const [layoutIdStr, sizeIdStr] = layoutSizeKey.split('-');
      const layoutId = parseInt(layoutIdStr);
      const sizeId = parseInt(sizeIdStr);

      // Get all set IDs for this layout-size combo, sorted numerically
      const setIds = setList.map(s => s.id).sort((a, b) => a - b);

      // Build config key (no angle): "kilter/1/7/1,20"
      const configKey = `${boardName}/${layoutId}/${sizeId}/${setIds.join(',')}`;

      // Get image filenames for each set
      const imageFiles = [];
      for (const setId of setIds) {
        const key = `${layoutId}-${sizeId}-${setId}`;
        const filename = (data.IMAGE_FILENAMES[boardName] || {})[key];
        if (filename) {
          imageFiles.push(filename);
        }
      }

      if (imageFiles.length === 0) {
        console.warn(`  Skipping ${configKey}: no image files found`);
        continue;
      }

      // Get product size data for coordinate transforms
      const sizeData = (data.PRODUCT_SIZES[boardName] || {})[sizeId];
      if (!sizeData) {
        console.warn(`  Skipping ${configKey}: no size data`);
        continue;
      }

      // Get LED placements for this layout-size
      const ledKey = `${layoutId}-${sizeId}`;
      const ledPlacements = (data.LED_PLACEMENTS[boardName] || {})[ledKey] || {};

      // Collect all hold tuples from all sets
      const allHolds = [];
      for (const setId of setIds) {
        const hpKey = `${layoutId}-${setId}`;
        const holds = (data.HOLE_PLACEMENTS[boardName] || {})[hpKey] || [];
        allHolds.push(...holds);
      }

      configs.push({
        boardName,
        layoutId,
        sizeId,
        setIds,
        configKey,
        imageFiles,
        sizeData,
        ledPlacements,
        allHolds,
        boardImageDimensions: data.BOARD_IMAGE_DIMENSIONS,
      });
    }
  }

  console.log(`\nEnumerated ${configs.length} board configurations`);
  return configs;
}

/**
 * Sanitize a config key to be a valid C++ identifier
 * e.g., "kilter/1/7/1,20" -> "kilter_1_7_1_20"
 */
function sanitizeId(configKey) {
  return configKey.replace(/[/,]/g, '_');
}

/**
 * Compute hold mappings for a config: for each hold that has an LED position,
 * calculate its pixel coordinates in the resized image.
 */
function computeHoldMap(config, targetWidth, targetHeight) {
  const { sizeData, ledPlacements, allHolds, boardImageDimensions, imageFiles, boardName } = config;
  const { edgeLeft, edgeRight, edgeBottom, edgeTop } = sizeData;

  // Get source image dimensions from the first image file
  const firstImage = imageFiles[0];
  const dims = (boardImageDimensions[boardName] || {})[firstImage];
  const boardWidth = dims?.width ?? 1080;
  const boardHeight = dims?.height ?? 1920;

  // Coordinate transform (same as getBoardDetails in product-sizes-data.ts)
  const xSpacing = boardWidth / (edgeRight - edgeLeft);
  const ySpacing = boardHeight / (edgeTop - edgeBottom);

  // Scale factor from source image to target display size
  const scaleX = targetWidth / boardWidth;
  const scaleY = targetHeight / boardHeight;

  // Build reverse LED map: placementId -> ledPosition
  const placementToLed = {};
  for (const [placementIdStr, ledPos] of Object.entries(ledPlacements)) {
    placementToLed[parseInt(placementIdStr)] = ledPos;
  }

  const holdMap = [];

  for (const hold of allHolds) {
    const [placementId, , x, y] = hold;

    // Check if this hold has an LED position
    const ledPosition = placementToLed[placementId];
    if (ledPosition === undefined) continue;

    // Filter holds outside the board edges (same as getBoardDetails)
    if (x <= edgeLeft || x >= edgeRight || y <= edgeBottom || y >= edgeTop) continue;

    // Compute pixel coordinates in source image space
    const srcCx = (x - edgeLeft) * xSpacing;
    const srcCy = boardHeight - (y - edgeBottom) * ySpacing;
    const srcR = xSpacing * 4;

    // Scale to target image dimensions
    const cx = Math.round(srcCx * scaleX);
    const cy = Math.round(srcCy * scaleY);
    const r = Math.max(3, Math.round(srcR * scaleX));

    holdMap.push({ ledPosition, cx, cy, r });
  }

  // Sort by ledPosition for binary search on firmware
  holdMap.sort((a, b) => a.ledPosition - b.ledPosition);

  return holdMap;
}

/**
 * Composite multiple PNG layers and convert to JPEG buffer
 */
async function compositeAndResize(config) {
  const sharp = (await import('sharp')).default;
  const { boardName, imageFiles, boardImageDimensions } = config;

  // Get dimensions from first image
  const firstImage = imageFiles[0];
  const dims = (boardImageDimensions[boardName] || {})[firstImage];
  const srcWidth = dims?.width ?? 1080;
  const srcHeight = dims?.height ?? 1920;

  // Calculate target dimensions preserving aspect ratio
  const aspect = srcWidth / srcHeight;
  let targetWidth, targetHeight;
  if (aspect > MAX_IMAGE_WIDTH / MAX_IMAGE_HEIGHT) {
    // Width-limited
    targetWidth = MAX_IMAGE_WIDTH;
    targetHeight = Math.round(MAX_IMAGE_WIDTH / aspect);
  } else {
    // Height-limited
    targetHeight = MAX_IMAGE_HEIGHT;
    targetWidth = Math.round(MAX_IMAGE_HEIGHT * aspect);
  }

  // Load and composite layers
  const imagePaths = imageFiles.map(f =>
    path.join(IMAGES_BASE, boardName, f)
  );

  // Check all images exist
  const existingPaths = imagePaths.filter(p => fs.existsSync(p));
  if (existingPaths.length === 0) {
    console.warn(`  No image files found for ${config.configKey}`);
    return null;
  }

  // Resize all layers to a common size (srcWidth x srcHeight), then composite
  // We must materialize the base to a buffer first because sharp's composite
  // requires overlay dimensions to match the already-realized base image.
  let baseBuffer = await sharp(existingPaths[0])
    .resize(srcWidth, srcHeight, { fit: 'fill', kernel: 'lanczos3' })
    .png()
    .toBuffer();

  // Composite additional layers on top
  if (existingPaths.length > 1) {
    const overlays = [];
    for (const p of existingPaths.slice(1)) {
      const resizedOverlay = await sharp(p)
        .resize(srcWidth, srcHeight, { fit: 'fill', kernel: 'lanczos3' })
        .png()
        .toBuffer();
      overlays.push({ input: resizedOverlay, blend: 'over' });
    }
    baseBuffer = await sharp(baseBuffer).composite(overlays).png().toBuffer();
  }

  // Resize composited image to target dimensions and convert to JPEG
  const jpegBuffer = await sharp(baseBuffer)
    .resize(targetWidth, targetHeight, { fit: 'fill', kernel: 'lanczos3' })
    .jpeg({ quality: JPEG_QUALITY })
    .toBuffer();

  return { buffer: jpegBuffer, width: targetWidth, height: targetHeight };
}

/**
 * Format a byte array as a C++ array initializer
 */
function formatByteArray(buffer, indent = '    ') {
  const bytes = Array.from(buffer);
  const lines = [];
  for (let i = 0; i < bytes.length; i += 16) {
    const chunk = bytes.slice(i, i + 16);
    lines.push(indent + chunk.map(b => '0x' + b.toString(16).padStart(2, '0')).join(', '));
  }
  return lines.join(',\n');
}

/**
 * Generate the board_image_data.h header with PROGMEM JPEG arrays
 */
function generateImageHeader(configResults) {
  let content = `/**
 * Auto-generated Board Image Data for ESP32 Firmware
 *
 * DO NOT EDIT MANUALLY - This file is generated by:
 *   npm run controller:codegen:board-data
 *
 * Contains JPEG image data for each board configuration,
 * stored in PROGMEM for direct rendering on the display.
 *
 * Generated at: ${new Date().toISOString()}
 */

#pragma once
#include <stdint.h>
#include <stddef.h>
#include <pgmspace.h>

`;

  for (const result of configResults) {
    const id = sanitizeId(result.configKey);
    content += `// ${result.configKey} (${result.width}x${result.height}, ${result.buffer.length} bytes)\n`;
    content += `static const uint8_t image_${id}[] PROGMEM = {\n`;
    content += formatByteArray(result.buffer);
    content += '\n};\n\n';
  }

  return content;
}

/**
 * Generate the board_hold_data.h header with type definitions and declarations only.
 * The actual data arrays and implementations go in board_data.cpp.
 */
function generateHoldHeader(configResults) {
  let content = `/**
 * Auto-generated Board Hold Mapping Types for ESP32 Firmware
 *
 * DO NOT EDIT MANUALLY - This file is generated by:
 *   npm run controller:codegen:board-data
 *
 * Contains type definitions for hold position mappings and board configs.
 * Actual data arrays are in board_data.cpp (same library).
 *
 * Generated at: ${new Date().toISOString()}
 */

#pragma once
#include <stdint.h>
#include <stddef.h>

struct HoldMapEntry {
    uint16_t ledPosition;
    uint16_t cx;     // pixel x in resized image
    uint16_t cy;     // pixel y in resized image
    uint8_t radius;  // pixel radius for circle overlay
};

struct BoardConfig {
    const char* configKey;      // e.g., "kilter/1/7/1,20" (no angle)
    const uint8_t* imageData;
    size_t imageSize;
    uint16_t imageWidth;
    uint16_t imageHeight;
    const HoldMapEntry* holdMap;
    uint16_t holdCount;
};

extern const BoardConfig BOARD_CONFIGS[];
extern const int BOARD_CONFIG_COUNT;

const BoardConfig* findBoardConfig(const char* configKey);
`;

  return content;
}

/**
 * Generate board_data.cpp with all data arrays, lookup table, and findBoardConfig.
 * This file is compiled once and links the image data with hold mappings.
 */
function generateDataCpp(configResults) {
  let content = `/**
 * Auto-generated Board Data Implementation for ESP32 Firmware
 *
 * DO NOT EDIT MANUALLY - This file is generated by:
 *   npm run controller:codegen:board-data
 *
 * Contains hold mapping arrays, the master lookup table (BOARD_CONFIGS),
 * and the findBoardConfig() implementation. Includes board_image_data.h
 * for the JPEG image arrays.
 *
 * Generated at: ${new Date().toISOString()}
 */

#include "board_image_data.h"
#include "board_hold_data.h"
#include <string.h>
#include <pgmspace.h>

`;

  // Generate hold mapping arrays
  for (const result of configResults) {
    const id = sanitizeId(result.configKey);
    if (result.holdMap.length === 0) {
      content += `// ${result.configKey}: no LED-mapped holds\n`;
      content += `static const HoldMapEntry holds_${id}[] PROGMEM = {{0, 0, 0, 0}};\n\n`;
    } else {
      content += `// ${result.configKey}: ${result.holdMap.length} holds\n`;
      content += `static const HoldMapEntry holds_${id}[] PROGMEM = {\n`;
      const entries = result.holdMap.map(h =>
        `    {${h.ledPosition}, ${h.cx}, ${h.cy}, ${h.r}}`
      );
      content += entries.join(',\n');
      content += '\n};\n\n';
    }
  }

  // Generate master lookup table
  content += `// Master lookup table - ${configResults.length} configurations\n`;
  content += `const BoardConfig BOARD_CONFIGS[] PROGMEM = {\n`;
  for (const result of configResults) {
    const id = sanitizeId(result.configKey);
    const holdCount = result.holdMap.length || 0;
    content += `    {"${result.configKey}", image_${id}, sizeof(image_${id}), ${result.width}, ${result.height}, holds_${id}, ${holdCount}},\n`;
  }
  content += `};\n`;
  content += `const int BOARD_CONFIG_COUNT = ${configResults.length};\n\n`;

  // Generate lookup function
  content += `/**
 * Find a board configuration by its config key.
 * Config key format: "board_name/layout_id/size_id/set_ids"
 * (angle is stripped from boardPath before lookup)
 */
const BoardConfig* findBoardConfig(const char* configKey) {
    for (int i = 0; i < BOARD_CONFIG_COUNT; i++) {
        if (strcmp(BOARD_CONFIGS[i].configKey, configKey) == 0) {
            return &BOARD_CONFIGS[i];
        }
    }
    return nullptr;
}
`;

  return content;
}

async function main() {
  console.log('Board Data Code Generator');
  console.log('=========================\n');

  // Load source data
  const data = loadBoardData();

  // Enumerate all configurations
  const configs = enumerateConfigs(data);

  // Process each configuration
  const results = [];
  let totalImageBytes = 0;
  let totalHolds = 0;

  for (const config of configs) {
    process.stdout.write(`  Processing ${config.configKey}... `);

    try {
      const imageResult = await compositeAndResize(config);
      if (!imageResult) {
        console.log('SKIPPED (no images)');
        continue;
      }

      const holdMap = computeHoldMap(config, imageResult.width, imageResult.height);

      results.push({
        configKey: config.configKey,
        buffer: imageResult.buffer,
        width: imageResult.width,
        height: imageResult.height,
        holdMap,
      });

      totalImageBytes += imageResult.buffer.length;
      totalHolds += holdMap.length;
      console.log(`${imageResult.width}x${imageResult.height}, ${imageResult.buffer.length} bytes, ${holdMap.length} holds`);
    } catch (err) {
      console.log(`ERROR: ${err.message}`);
    }
  }

  console.log(`\nProcessed ${results.length} configurations`);
  console.log(`Total image data: ${(totalImageBytes / 1024 / 1024).toFixed(2)} MB`);
  console.log(`Total holds: ${totalHolds}`);

  // Generate output files
  console.log('\nGenerating C++ source files...');

  // Ensure output directory exists
  if (!fs.existsSync(OUTPUT_DIR)) {
    fs.mkdirSync(OUTPUT_DIR, { recursive: true });
  }

  // Generate image data header
  const imageHeader = generateImageHeader(results);
  const imageHeaderPath = path.join(OUTPUT_DIR, 'board_image_data.h');
  fs.writeFileSync(imageHeaderPath, imageHeader);
  console.log(`  Written: ${imageHeaderPath} (${(imageHeader.length / 1024).toFixed(0)} KB source)`);

  // Generate hold data header (types + declarations only)
  const holdHeader = generateHoldHeader(results);
  const holdHeaderPath = path.join(OUTPUT_DIR, 'board_hold_data.h');
  fs.writeFileSync(holdHeaderPath, holdHeader);
  console.log(`  Written: ${holdHeaderPath} (${(holdHeader.length / 1024).toFixed(0)} KB source)`);

  // Generate board data implementation (all data arrays + lookup)
  const dataCpp = generateDataCpp(results);
  const dataCppPath = path.join(OUTPUT_DIR, 'board_data.cpp');
  fs.writeFileSync(dataCppPath, dataCpp);
  console.log(`  Written: ${dataCppPath} (${(dataCpp.length / 1024).toFixed(0)} KB source)`);

  // Verify JPEG magic bytes
  let validJpegs = 0;
  for (const result of results) {
    if (result.buffer[0] === 0xFF && result.buffer[1] === 0xD8) {
      validJpegs++;
    }
  }
  console.log(`\nJPEG validation: ${validJpegs}/${results.length} valid`);

  console.log('\nDone!');
}

main().catch(err => {
  console.error('Fatal error:', err);
  process.exit(1);
});
